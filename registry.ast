entry [nodes
	KWFun ? set="nodes" back="0"
	KWStruct ? set="nodes" back="1"
	KWType ? set="nodes" back="2"
	KWImpl ? set="nodes" back="3"
	KWTrait ? set="nodes" back="4"
	"'eof";


"
: type
usually for function arguments declaration 
fun danda(txt: String){}
"
type_specifier type
	: harderr="true"
	type set="type";


"
[int; 50]
int
int<float<[int; 50]>>
etc..
"
type main generic ref arr
	ref_type ? set="ref"
	function_head ? set="main" end="false"
	array_decl ? set="arr" end="false"
	type_ident_null set="main"
	generic_expr ? set="generic";

ref_type [refs
	& ? set="refs" back="0"
	&& ? set="refs" back="1";

type_ident [nodes
	ident set="nodes"
	. ? back="1";


type_ident_null [nodes nullable
	ident set="nodes"
	. ? back="1"
	? ? set="nullable";

"
[int; 60]
"
array_decl type size
	[
	type set="type"
	;
	expression set="size"
	];


"
type danda = int;
"
KWType identifier type generic public
	"pub" ? set="public"
	"type" harderr="true"
	ident set="identifier"
	generic_decl ? set="generic"
	=
	type set="type"
	;?;

"
struct Danda <T> {
	name: String,
	age: int,
	things: [T, 50],
}
"
KWStruct identifier [keys generic public
	"pub" ? set="public"
	"struct" harderr="true"
	ident set="identifier"
	generic_decl ? set="generic"
	{
	arg ? set="keys"
	, ? back="1"
	};


"
impl Danda(Rusty) {
	fun move(self){}
}
"
KWImpl identifier [traits [methods
	"impl" harderr="true"
	type_ident set="identifier"
	"trait" ?
		type_ident set="traits"
		, ? back="1"
	{
	KWOverload ? set="methods" back="0"
	KWFun ? set="methods" back="1"
	};


"
trait Rusty (Danda){
	fun print (self){
		// i can access methods belonging to Danda trait
		// for example 
		let name = self.name()
		print(name)
	}
}
"
KWTrait identifier [traits [methods public
	"pub" ? set="public"
	"trait" harderr="true"
	ident set="identifier"
	"impl" ?
		type_ident set="traits"
		, ? back="1"
	{
	KWOverload ? set="methods" back="0"
	KWFun ? set="methods" back="1"
	};


"
fun parse_str<Type>(str: String): Type {}
fun danda() {}
fun danda(&self) {}
fun danda(self) {}
"
KWFun identifier generic [arguments type code errorable public
	"pub" ? set="public"
	"fun" harderr="true"
	ident set="identifier"
	generic_decl ? set="generic"
	(
	self_arg ? set="arguments"
	arg ? set="arguments"
	, ? back="1"
	)
	! ? set="errorable"
	type_specifier ? set="type"
	code_block ? set="code" returnable="true";

KWOverload op arg type code generic errorable public
	"pub" ? set="public"
	"overload" harderr="true"
	overloadable_op set="op"
	generic_decl ? set="generic"
	(
	arg set="arg"
	)
	! ? set="errorable"
	type_specifier ? set="type"
	code_block ? set="code" returnable="true";


self_arg args ref
	ref_type ? set="ref"
	"self" set="args";

generic_decl [identifiers
	< harderr="true"
	generic_ident set="identifiers"
	, ? back="1"
	>;
	
arg identifier type
	ident set="identifier" harderr="true"
	:
	type set="type";

set_op op
	= ? set="op" end="true"
	+= ? set="op" end="true"
	-= ? set="op" end="true"
	/= ? set="op" end="true"
	*= ? set="op" end="true"
	"'any" err="not a setting operator";

operator op
	< ? set="op" end="true"
	<= ? set="op" end="true"
	>= ? set="op" end="true"
	> ? set="op" end="true"
	+ ? set="op" end="true"
	- ? set="op" end="true"
	* ? set="op" end="true"
	/ ? set="op" end="true"
	!= ? set="op" end="true"
	== ? set="op" end="true"
	| ? set="op" end="true"
	& ? set="op" end="true"
	|| ? set="op" end="true"
	&& ? set="op" end="true"
	% ? set="op" end="true"
	"'any" err="";

overloadable_op op
	< ? set="op" end="true"
	<= ? set="op" end="true"
	>= ? set="op" end="true"
	> ? set="op" end="true"
	+ ? set="op" end="true"
	- ? set="op" end="true"
	* ? set="op" end="true"
	/ ? set="op" end="true"
	+= ? set="op" end="true"
	-= ? set="op" end="true"
	*= ? set="op" end="true"
	/= ? set="op" end="true"
	== ? set="op" end="true"
	| ? set="op" end="true"
	& ? set="op" end="true"
	|| ? set="op" end="true"
	&& ? set="op" end="true"
	% ? set="op" end="true"
	[ ? set="op" end="true"
	! ? set="op" end="true"
	"'any" err="";

ref_tok [tokens
	* ? set="tokens" back="0"
	& ? set="tokens" back="1"
	&& ? set="tokens" back="2";

nested identifier
	. harderr="true"
	ident set="identifier";

RESERVED
	"const" ? end="false"
	"let" ? end="false"
	"if" ? end="false"
	"while" ? end="false"
	"fun" ? end="false"
	"impl" ? end="false"
	"struct" ? end="false"
	"yeet" ? end="false"
	"continue" ? end="false"
	"break" ? end="false"
	"as" ? end="false"
	"new" ? end="false"
	"'any" err="v poradku";

ident identifier
	RESERVED ? err="identifier name is reserved"
	"'text" set="identifier";